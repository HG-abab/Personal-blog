## 一、😆 for循环和forEach对比

> 测试for与forEach在遍历相同足够大的数据时所消耗的时间

#### 1. for

```language
<script>
  let arrs = [...Array(999999).keys()]
  let total = 0
  let startTime = Date.now()
  for (let i = 0; i < arrs.length; i++) {
    total += i
  }
  let endTime = Date.now()
  let countTime = endTime - startTime
  console.log(total, Date.now() - startTime)
</script>
1. 结果：
499998500001 9
```

#### 2. forEach

```language
<script>
  let arrs = [...Array(999999).keys()]
  let total = 0
  let startTime = Date.now()
  arrs.forEach(i => {
    total += i
  })
  let endTime = Date.now()
  let countTime = endTime - startTime
  console.log(total, Date.now() - startTime)
</script>
结果：
499998500001 13
```

### for与forEach注意事件

> 在for中可以通过条件判断后break跳出结束，而forEach中不能，forEach会执行完才结束

#### 1. for

```language
<script>
  let arrs = [...Array(999999).keys()]
  let total = 0
  let startTime = Date.now()
  for (let i = 0; i < arrs.length; i++) {
    if (i === 10) break;
    total += i
  }
  let endTime = Date.now()
  let countTime = endTime - startTime
  console.log(total, Date.now() - startTime)
</script>
1. 结果：
45 0
```

#### 2. forEach

```language
<script>
  let arrs = [...Array(999999).keys()]
  let total = 0
  let startTime = Date.now()
  arrs.forEach(i => {
    if (i == 10) return;
    total += i
  })
  let endTime = Date.now()
  let countTime = endTime - startTime
  console.log(total, Date.now() - startTime)
</script>
结果：
499998499991 13
```

### 结论

> 如果if(item===10) return;类似于continue只会结束当次循环，后面的11、12…会继续++，所以消耗的计数会继续累加，循环次数继续全部完成，这样写不会节省时间；
>
> 如果if(item>10) return; 可以让10后面所有的计算全部退出，那么就不会再进行计数了，最终的结果肯定是10之前的计数，return后面所有的累计不计算了，所以节省了整个的计算时间

## 二、🤔map()方法

> map() 方法是数组原型的一个函数，对数组遍历不破坏原数组，将会创建一个新数组，按照原始数组元素顺序依次执行给定的函数，map方法非常适合用于处理数组中的每个元素并生成新的数组。

### 用法

#### 1. 将数组内每个元素×2后，获取新数组

```language
let arrs = [1,2,3,4];
let newArrs = arrs.map(item=>item*2);
console.log(newArrs);
// [2, 4, 6, 8]
```

#### 2. 将数组对象内每个元素的名称拿出来，作为一个新数组

```language
let arrs = [
    {name: "榴莲", price: 1111},
    {name: "苹果", price: 22222},
    {name: "香蕉", price: 3333}
  ]
  let newArrs = arrs.map(item => item.name);
  console.log(newArrs);

  // ['榴莲', '苹果', '香蕉']
```

#### 3. 将原数组中属性进行更换，配合对象解构，可以更直观

```language
  let arrs = [
    {key: 0, content: "篮球"},
    {key: 1, content: "足球"},
    {key: 2, content: "排球"}
  ];
  let newArrs = arrs.map(({key, content}) => (
    {
      value: key,
      text: content
    }
  ));
  console.log(newArrs);

// [
{value: 0, text: '篮球'},
{value: 1, text: '足球'},
{value: 2, text: '排球'}
]
```

#### 4. 将异步请求map到新数组中，使用Promise.all同时处理多个Promise

##### 1. for请求时

```language
<script>
  async function fetchData() {
    let arrs = Array.from({length: 3}, (_, index) => index + 1);
    let datas = [];
    for (let i = 0; i < arrs.length; i++) {
      try {
        const response = await axios.get("http://jsonplaceholder.typicode.com/posts/" + arrs[i]);
        datas.push(response.data);  // 使用 response.data 来获取返回的 JSON 数据
      } catch (error) {
        console.error("请求失败：", error);
      }
    }
    console.log(datas);
  }
  fetchData();

  // 输出: [{...}, {...}, {...}]
</script>
```

![](https://pic.imgdb.cn/item/67618283d0e0a243d4e58672.png)

> 使用for循环的时候能满足需求，但会执行完第一个在执行第二个，性能低时间加载慢

#### 5. 下面这个利用map，解决for循环异步同步化性能消耗过大的问题。

```language
<script>
  let arrs = Array.from({length: 3}, (_, index) => index + 1);
  let datas = [];
  const promise = arrs.map(async (item) => {
    try {
      const response = await axios.get("http://jsonplaceholder.typicode.com/posts/" + item);
      datas.push(response.data);  // 使用 response.data 来获取返回的 JSON 数据
    } catch (error) {
      console.error("请求失败：", error);
    }
  })
  console.log(datas);
</script>
```

![](https://pic.imgdb.cn/item/67618300d0e0a243d4e586a6.png)

### 结论

> 三个网络请求同时发布，时间消耗相较于for请求更快

## 三、😤filter()方法

> filter()过滤方法，会对原数组中的每个元素应用指定的函数，并返回一个新数组，其中包含符合条件的元素。原数组不会受到影响。

### 用法

> 在filter回调函数中，满足true即可被处理到新函数中，false不做处理。

#### 1. 找出数组中大于10的数据放到新数组中

```language
let arrs = [5,7,8,15,22,1,2];
let newArrs = arrs.filter(item=>{
    return item>10
})
console.log(newArrs);

// [15,22]

//如果是数组对象的话也是一样的，只需要找到满足的对象属性即可，比如找到数组对象中，年龄小于30岁的数据：
let arrs = [
    {name:"张三",age:16},
    {name:"李四",age:40},
    {name:"王五",age:28},
    {name:"汤姆",age:20}
];
let newArrs = arrs.filter(item=>{
    return item.age<30
})
console.log(newArrs);

//[{name:"张三",age:16},...]
```

#### 2. 数组去重，结合indexOf方法

```language
let arrs = [6,1,2,3,5,3,6];
let newArrs = arrs.filter((item,index,self)=>{
    return self.indexOf(item) === index
})
console.log(newArrs);

// [6, 1, 2, 3, 5]
```

#### 3. 数组对象中过滤掉无用数据

```language
let arrs = [
    {id:1,name:"HTML5"},
    {id:2,name:"JavaScript"},
    {id:null,name:"小程序"},
    {name:"NodeJS"},
    {id:3,name:"VueJS"}
];
let newArrs = arrs.filter(item=>{
    return item.id
})
console.log(newArrs);

// [ {id: 1, name: 'HTML5'},...]
```

#### 4. filter和map组合使用，可以使用链式写法；首先去除无用数据，然后给每一条增加一个属性

```language
let arrs = [
    {id:1,name:"HTML5"},
    {id:2,name:"JavaScript"},
    {id:null,name:"小程序"},
    {name:"NodeJS"},
    {id:3,name:"VueJS"}
];
let newArrs = arrs.filter(item=>{
    return item.id
}).map(item=>{
    return {
        ...item,
        ababab:"123"
    }
})
console.log(newArrs);

// [{id: 1, name: 'HTML5', ababab: '123'},...]
```

## 四、😣reduce()方法

> reduce() 方法对数组中的每个元素按序执行一个指定方法，每一次运行 reducer 会将先前元素的计算结果作为参数传入。

### 参数

```language
- prev（必填），上一次调用 callbackFn 的结果。
- current（必填），当前元素的值。
- index（可选），current 在数组中的索引位置。
- array（可选），调用了reduce() 的数组本身
```

### 用法

#### 1. 数组求和 / 求积

```language
let arrs = [1, 2, 3, 4];
  let result = arrs.reduce((prev, current, index) => {
    console.log(prev, current, index);
    return prev + current;
  })
  console.log("最终结果:" + result);
```

![](https://pic.imgdb.cn/item/67618336d0e0a243d4e586ae.png)

#### 2. 求最大值/最小值

```language
let arrs = [5, 6, 1, 22, 3, 7];
  let result = arrs.reduce((prev, current, index) => {
    console.log(prev, current, index);
    return Math.max(prev, current);
  }, 0)
  console.log(result);

  //22
```

#### 3. 对数组对象处理

```language
<script>
  let arrs = [
    {name: "张三", age: 29},
    {name: "李四", age: 16},
    {name: "王五", age: 50},
    {name: "小明", age: 21}
  ];
  let result = arrs.reduce((prev, current, index) => {
    return prev + current.age
  }, 0)
  console.log(result);

  // 116
</script>
```

## 五、🥸every()方法

> 判断数组中所有元素是否满足函数中给定的条件，全部满足返回true,只要有一项不满足则返回false。

### 用法

#### 1. 检查数组中的所有元素是否满足特定条件

```language
let arrs = [1, 2, 3, 4, 5];
let result = arrs.every(num => num > 0);
console.log(result);

//true
```

#### 2. 检测数组对象中，是否所有商品都有库存

```language
<script>
  let arrs = [
    {name: "华为", price: 5899, stock: true},
    {name: "苹果", price: 9999, stock: false},
    {name: "小米", price: 4399, stock: true},
    {name: "红米", price: 899, stock: true}
  ];
  let result = arrs.every(item => item.stock);
  console.log(result);
  // false
</script>
```

## 六、🥳some()方法

> some方法和every方法基本类似，只是some方法检测数组中，只要有一个满足条件即返回true，全部不满足条件才会返回false。

### 用法

#### 1. 检查数组中的是否有满足特定条件的元素

```language
let arrs = [55,26,3,12,39];
let result  = arrs.some(item=>item<10);
console.log(result);
// true
```

#### 2. 检查数组对象中，是否有满足price小于1000的元素，并且有stock库存

```language
 let arrs = [
    {name: "华为", price: 5899, stock: true},
    {name: "苹果", price: 9999, stock: false},
    {name: "小米", price: 4399, stock: true},
    {name: "红米", price: 899, stock: true}
  ];
  let result = arrs.some(item => item.price < 1000 && item.stock);
  console.log(result);
  // true
```

## 七、🤬includes()方法

> includes() 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回 false。

### 注意

> includes() 方法只能用于检测基础数据类型（如数字、字符串、布尔值），而不能用于检测包含对象或其他数组的二维数组。如果需要检测对象或其他复杂数据类型，可以使用其他方法或自定义函数来实现。

### 用法

#### 1. 基础用法

```language
const arrs = [1, 2, 3];
console.log(arrs.includes(2));

// true
```

#### 2. every和includes配合，检测一个数组是否包含另一个数组

```language
let arrs1 = [1,2,3,4,5,6,7];
let arrs2 = [2,5,7];
let arrs3 = [1,6,9];
let result1 = arrs2.every(item=>arrs1.includes(item));
let result2 = arrs3.every(item=>arrs1.includes(item));
console.log(result1);   // true
console.log(result2);  // false
```

## 八、🥸find()方法

> find() 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回

### 用法

#### 1. 在对象数组中通过对象属性进行查找

```language
const inventory = [
  { name: "apples", quantity: 2 },
  { name: "bananas", quantity: 0 },
  { name: "cherries", quantity: 5 },
];

function isCherries(fruit) {
  return fruit.name === "cherries";
}

console.log(inventory.find(isCherries));
// { name: 'cherries', quantity: 5 }
```

#### 2. 寻找数组中的第一个素数

```language
function isPrime(element, index, array) {
  let start = 2;
  while (start <= Math.sqrt(element)) {
    if (element % start++ < 1) {
      return false;
    }
  }
  return element > 1;
}
console.log([4, 6, 8, 12].find(isPrime)); // undefined，未找到
console.log([4, 5, 8, 12].find(isPrime)); // 5
```

## 九、😖findIndex()方法

> findIndex() 方法返回数组中满足提供的测试函数的第一个元素的索引。若没有找到对应元素则返回 -1。

### 用法

#### 1. 寻找数组中的首个素数的索引

```language
function isPrime(element) {
  if (element % 2 === 0 || element < 2) {
    return false;
  }
  for (let factor = 3; factor <= Math.sqrt(element); factor += 2) {
    if (element % factor === 0) {
      return false;
    }
  }
  return true;
}

console.log([4, 6, 8, 9, 12].findIndex(isPrime)); // -1，没有找到
console.log([4, 6, 7, 9, 12].findIndex(isPrime)); // 2（array[2] 是 7）

```

## 十、😚findLast()方法

> findLast() 方法反向迭代数组，并返回满足提供的测试函数的第一个元素的值。如果没有找到对应元素，则返回 undefined。
